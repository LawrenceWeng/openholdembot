
//*****************************************************************************
//
// OpenPPL - BettingAction Symbols
//
//*****************************************************************************

##InitBets##
// No bet in front of us to call
((currentbet == 0) AND (AmountToCall == 0)) ? me_st_MemBets_0 :
// A bet to call and we didn't act before or we checked
((currentbet == 0) AND (AmountToCall > 0)) ? me_st_MemBets_1 :
// Otherwise: we did already bet ourself or call a bet.
// So don't change anything
HINT_Nothing_To_Do_But_All_OK

##Bets##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ me_re_MemBets

##BigBlindSittingOut##
(BigBlindChair < 0) ? ERROR_BigBlindChair_Not_Recognized__Check_Your_TableMap :
((playersactivebits >> BigBlindChair & 1) == 0)

##SmallBlindSittingOut##
(BigBlindChair < 0) ? ERROR_BigBlindChair_Not_Recognized__Check_Your_TableMap :
((playersactivebits >> SmallBlindChair & 1) == 0)

##OpponentsLeftSittingOut##
(opponentsactivebits & opponentsplayingbits) == 0

##AggressorChair##
// raischair (formerly ac_aggressor) alone is somewhat unreliable, as it gets scraped (by bets).
// But if we raise and there are super-fast calls behind us (e.g. at PokerAcademy),
// then we don't have stable frames and soon we will switch to the next betting round.
// (There are however no problems, if somebody else raises,
// because we always get stable frames at out turn.)
// So we also check for our last action and the amount to call.
// (-1 = fold 0 = check 1 = call 2 = raise e3 = betsize 4 = allin)
(((prevaction ==  2) OR (prevaction == 3)) AND (AmountToCall == 0)) ? userchair :
raischair

##LastAggressorActsAfterUs##		
   ac_agchair_after 
AND NOT BotIsLastRaiser

##BotIsLastRaiser##
(AggressorChair==userchair)

##BotRaisedBeforeFlop##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didraisround1 
OR didbetsizeround1

##BotRaisedOnFlop##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didraisround2 
OR didbetsizeround2

##BotRaisedOnTurn##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didraisround3 
OR didbetsizeround3

##BotsActionsOnFlop##
  (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : 0)
// Checks are not counted
+ didcallround2 
+ didraisround2 
+ didbetsizeround2

##BotsActionsOnThisRound##
  (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : 0)
// Checks are not counted
+ didcall 
+ didrais 
+ didbetsize

##BotsActionsOnThisRoundIncludingChecks##
  (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : 0)
// Folds and allins are not relevant, as then the hand is over for us.
+ didchec 
+ didcall 
+ didbetsize 
+ didrais

##BotsActionsPreflop##
  (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : 0)
// Checks are not counted per definition
// and we can't check preflop without posting a blind out of order (first hand only).
+ didcallround1 
+ didraisround1 
+ didbetsizeround1

##PrevActionWasAllin##
   (prevaction == 4) // Allin
OR (prevaction == 5) // Jamming the slider

##BotsLastAction##
// Just to be extra safe...
[(betround == ConstBetRoundPreflop) AND (BotsActionsOnThisRoundIncludingChecks == 0)] ? None :
// Caring about a possible check, when a fold could not have happened
[me_re_MemBotsLastAction == Fold] ? Check :
// Computing BotsLastAction from prevation
// k_prevaction_undefined = -2
// k_prevaction_fold = -1
// k_prevaction_check = 0		// new in OpenHoldem
// k_prevaction_call = 1
// k_prevaction_raise = 2		// min-raise
// k_prevaction_betsize = 3	// "stated wager", i.e. using f$betsize
// k_prevaction_allin = 4
// k_prevaction_jam = 5
//
// Successful allin
(PrevActionWasAllin AND (balance == 0)) ? RaiseMax :
// Failed allin
(PrevActionWasAllin AND (balance >= 0)) ? Raise :
// Raising (FL and NL)
((prevaction == 2) OR (prevaction == 3)) ? Raise :
// calling
(prevaction == 1) ? Call :
// Checking postflop
((prevaction == 0) AND (betround > 1) AND (currentbet == 0)) ? Check :
// Checking preflop
((prevaction == 0) AND (betround == 1) AND (currentbet <= bblind)) ? Check :
// "Checking" when it was a call
// Actually OH does auto-adapt prevaction after such actions
// but we try to be extra safe
((prevaction == 0) AND (betround == 1) AND (currentbet > bblind)) ? Call :
// Folding (might be used in sitour formulas)
(prevaction == -1) ? Fold :
// No autoplayer-actions, but human being at ManualMode
sitename$openholdem ? (HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions + None) : 
// None
(prevaction == -1) ? None :
ERROR_IncorrectBotsLastAction

##InitBotsLastPreflopAction##
// Don't use BotsLastAction on the first orbit,
// because that variable has to be the last one to be initialized
// and is therefore undefined.
[(betround == ConstBetRoundPreflop) AND (BotsActionsOnThisRoundIncludingChecks == 0)] ? 
    me_st_MemBotsLastPreflopAction_None :
[(betround == ConstBetRoundPreflop) AND (BotsActionsOnThisRoundIncludingChecks > 0)] ? 
    me_st_MemBotsLastPreflopAction_BotsLastAction : 
[(betround == ConstBetRoundFlop) AND (BotsActionsOnThisRoundIncludingChecks == 0)] ?
    me_st_MemBotsLastPreflopAction_BotsLastAction : 0  

##BotsLastPreflopAction##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ me_re_MemBotsLastPreflopAction

##BotCalledBeforeFlop##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didcallround1

##BotCalledOnFlop##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didcallround2

##BotCalledOnTurn##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didcallround3

##BotCalledOnRiver##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didcallround4

##BotCheckedPreflop##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didchecround1

##BotCheckedOnFlop##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didchecround2

##BotCheckedOnTurn##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didchecround3

##BotCheckedOnRiver##
   (sitename$openholdem ? HINT_Counting_Only_Autoplayer_Actions_Not_Manual_User_Actions : False)
OR didchecround4

##AddNopponentscalling##
Calls + nopponentscalling

##InitCalls##
(BotsActionsOnThisRoundIncludingChecks == 0) ?
  me_st_MemCalls_nopponentscalling :
  me_st_MemCalls_AddNopponentscalling

##Calls##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ ismyturn ? me_re_MemCalls :
ERROR_Action_History_Only_Valid_On_My_Turn_Most_Favourite_PEBKAC

##LastRaiserCurrentBet##
raischair == 0 ? currentbet0 :
raischair == 1 ? currentbet1 :
raischair == 2 ? currentbet2 :
raischair == 3 ? currentbet3 :
raischair == 4 ? currentbet4 :
raischair == 5 ? currentbet5 :
raischair == 6 ? currentbet6 :
raischair == 7 ? currentbet7 :
raischair == 8 ? currentbet8 :
raischair == 9 ? currentbet9 :
HINT_There_Is_No_Raiser_Therefore_No_CurrentBet

##PlayersRaisingOrColdCallingTheLastRaise##
// Counting the last raiser + all cold callers
(LastRaiserCurrentBet <= 0) ? 0 :
  (currentbet0 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet1 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet2 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet3 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet4 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet5 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet6 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet7 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet8 == LastRaiserCurrentBet ? 1 : 0)
+ (currentbet9 == LastRaiserCurrentBet ? 1 : 0)

##CallsSinceLastRaise##
(PlayersRaisingOrColdCallingTheLastRaise <= 0) ? HINT_There_Is_No_Raiser_Therefore_No_CallsSinceLastRaise :
ismyturn ? (PlayersRaisingOrColdCallingTheLastRaise - 1) :
ERROR_Action_History_Only_Valid_On_My_Turn_Most_Favourite_PEBKAC

##Folds##
ismyturn ? 
[(betround == ConstBetRoundPreflop) ? (nplayersdealt  - nopponentsplaying - 1) :
 (betround == ConstBetRoundFlop)    ? (nplayersround2 - nopponentsplaying - 1) :
 (betround == ConstBetRoundTurn)    ? (nplayersround3 - nopponentsplaying - 1) :
 (betround == ConstBetRoundRiver)   ? (nplayersround4 - nopponentsplaying - 1) :
 ERROR_Betround_Out_Of_Range] :
ERROR_Action_History_Only_Valid_On_My_Turn_Most_Favourite_PEBKAC

##ChecksAfterHero##
// Valid second orbit only
// All active players with a zero bet
(BotsActionsOnThisRoundIncludingChecks == 0) ? 0 :
nopponentschecking

##ChecksInFrontOfHero##
// No checks preflop. Not even big blind can check (game over).
// We ignore additional blind-posters however.
(betround == ConstBetRoundPreflop) ? 0 :
// I did already act, so no longer any posters in front of me
(currentbet > 0) ? 0 :
// A bet to call, subtract all players with a non-zero bet in front of us
(AmountToCall > 0) ? (betposition - nopponentsbetting - 1):
// All players before us checked, not even open-folds can throw this logic off.
[betposition - 1]

##CalculateChecks##
(BotsActionsOnThisRoundIncludingChecks == 0) ? ChecksInFrontOfHero :
// Stored value of checks on previous orbit plus players behind
(BotsActionsOnThisRoundIncludingChecks == 1) ? (Checks + ChecksAfterHero) :
// There can no longer be any checking players, so don't change anything
HINT_Nothing_To_Do_But_All_OK

##InitChecks##
(BotsActionsOnThisRound <= 1) ? me_st_MemChecks_CalculateChecks : 
HINT_Nothing_To_Do_But_All_OK

##Checks##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ ismyturn ? me_re_MemChecks :
ERROR_Action_History_Only_Valid_On_My_Turn_Most_Favourite_PEBKAC

##DealPosition1Chair##
ac_dealpos0 == 1 ? 0 :
ac_dealpos1 == 1 ? 1 :
ac_dealpos2 == 1 ? 2 :
ac_dealpos3 == 1 ? 3 :
ac_dealpos4 == 1 ? 4 :
ac_dealpos5 == 1 ? 5 :
ac_dealpos6 == 1 ? 6 :
ac_dealpos7 == 1 ? 7 :
ac_dealpos8 == 1 ? 8 :
ac_dealpos9 == 1 ? 9 :
ERROR_DealPosition1Chair_Not_Recognized__Check_Your_TableMap

##CurrentbetOfDealPosition1Chair##
(DealPosition1Chair == 0) ? currentbet0 :
(DealPosition1Chair == 1) ? currentbet1 :
(DealPosition1Chair == 2) ? currentbet2 :
(DealPosition1Chair == 3) ? currentbet3 :
(DealPosition1Chair == 4) ? currentbet4 :
(DealPosition1Chair == 5) ? currentbet5 :
(DealPosition1Chair == 6) ? currentbet6 :
(DealPosition1Chair == 7) ? currentbet7 :
(DealPosition1Chair == 8) ? currentbet8 :
(DealPosition1Chair == 9) ? currentbet9 :
ERROR_DealPosition1Chair_Not_Recognized__Check_Your_TableMap

##PlayersBehindDealPosition2ChairDidAct##
// Needed for detection of missing small blind.
// First checking for folded players,
// because lots of newbies won't scrape-players correctly and mix everything up.
// This affects calculation of small blind, big blind,
// all positions and finally lots of other things...
(nopponentsfolded > 0) ? True :
// Then check for active players with a zero bet
[(playersplayingbits & 0b0000000001) AND (currentbet0 == 0)] ? False :
[(playersplayingbits & 0b0000000010) AND (currentbet1 == 0)] ? False :
[(playersplayingbits & 0b0000000100) AND (currentbet2 == 0)] ? False :
[(playersplayingbits & 0b0000001000) AND (currentbet3 == 0)] ? False :
[(playersplayingbits & 0b0000010000) AND (currentbet4 == 0)] ? False :
[(playersplayingbits & 0b0000100000) AND (currentbet5 == 0)] ? False :
[(playersplayingbits & 0b0001000000) AND (currentbet6 == 0)] ? False :
[(playersplayingbits & 0b0010000000) AND (currentbet7 == 0)] ? False :
[(playersplayingbits & 0b0100000000) AND (currentbet8 == 0)] ? False :
[(playersplayingbits & 0b1000000000) AND (currentbet9 == 0)] ? False :
True

##CalculateMissingSmallBlind##
// True, if SB is missing, false otherwise
// Should be called at our first action preflop only.
(CurrentbetOfDealPosition1Chair == sblind) ? False :
// If we are NOT the Second player to be dealt and see a bet 
// of 1 big blind left to the dealer, then it is the big blind (SB missing)
[(dealposition != 2) AND (CurrentbetOfDealPosition1Chair == bblind)] ? True :
// Problematic is only the case when I am in "big blind" (Second player to be dealt)
// * if bet of DealPosition1Chair > 1 bblind then SB raised and is present
// * if bet = 1 big blind and players "behind me" did act, then SB is present and limped
// * if bet = 1 big blind and players behind me still to act, then SB is missing
[(dealposition == 2) AND (CurrentbetOfDealPosition1Chair > bblind)] ? False :
// Case 2 and 3: precondition: bet = 1 big blind
[(dealposition == 2) AND PlayersBehindDealPosition2ChairDidAct] ? False :
[(dealposition == 2) AND NOT PlayersBehindDealPosition2ChairDidAct] ? True :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##InitMissingSmallBlind##
[(betround == ConstBetRoundPreflop) AND  (BotsActionsOnThisRoundIncludingChecks == 0)] ? 
me_st_MemMissingSmallBlind_CalculateMissingSmallBlind :
HINT_Nothing_To_Do_But_All_OK

##MissingSmallBlind##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ me_re_MemMissingSmallBlind

##NoBettingOnFlop##
(nbetsround2 == 0)

##NoBettingOnTurn##
(nbetsround3 == 0)

##NoVillainBetOrRaisedOnFlop##
((raisbits2 & ~(1<<userchair)) == 0)

##NoVillainBetOrRaisedOnTurn##
((raisbits3 & ~(1<<userchair)) == 0)

##OpponentCalledOnFlop##
    (betround > ConstBetRoundFlop)
AND ((didraisround2 + didbetsizeround2) == 1)
AND NOT didchecround2
AND NOT didcallround2
AND NoVillainBetOrRaisedOnFlop

##OpponentCalledOnTurn##
    (betround > ConstBetRoundTurn)
AND ((didraisround3 + didbetsizeround3) == 1)
AND NOT didchecround3
AND NOT didcallround3
AND NoVillainBetOrRaisedOnTurn

##OpponentStacksizeHeadsUp##
[bblind==0] ? ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap:
[nopponentsplaying == NumberOfOpponentsAllin] ? HINT_All_Opponents_Allin :
[nopponentsplaying-NumberOfOpponentsAllin > 1] ? ERROR_Game_Is_Not_HeadsUp :
// Even "no opponents" can happen: 
// http://www.maxinmontreal.com/forums/viewtopic.php?f=110&t=17915&start=30&p=124798&view=show#p124798
[nopponentsplaying < 1] ? ERROR_Game_Is_Not_HeadsUp :
[(playersplayingbits & 0b0000000001) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=0 AND balance0>0] ? Stack0:
[(playersplayingbits & 0b0000000010) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=1 AND balance1>0] ? Stack1:
[(playersplayingbits & 0b0000000100) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=2 AND balance2>0] ? Stack2:
[(playersplayingbits & 0b0000001000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=3 AND balance3>0] ? Stack3:
[(playersplayingbits & 0b0000010000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=4 AND balance4>0] ? Stack4:
[(playersplayingbits & 0b0000100000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=5 AND balance5>0] ? Stack5:
[(playersplayingbits & 0b0001000000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=6 AND balance6>0] ? Stack6:
[(playersplayingbits & 0b0010000000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=7 AND balance7>0] ? Stack7:
[(playersplayingbits & 0b0100000000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=8 AND balance8>0] ? Stack8:
[(playersplayingbits & 0b1000000000) AND (nopponentsplaying-NumberOfOpponentsAllin==1) 
  AND userchair!=9 AND balance9>0] ? Stack9:
ERROR_Game_Is_Not_HeadsUp


##InitRaisesBeforeFlop##
(betround == ConstBetRoundPreflop) ? me_st_MemRaisesBeforeFlop_Raises : 
HINT_Nothing_To_Do_But_All_OK

##InitRaisesOnFlop##
(betround == ConstBetRoundFlop) ? me_st_MemRaisesOnFlop_Raises : 
HINT_Nothing_To_Do_But_All_OK

##InitRaisesOnTurn##
(betround == ConstBetRoundTurn) ? me_st_MemRaisesOnTurn_Raises : 
HINT_Nothing_To_Do_But_All_OK

##NumberOfRaisesBeforeFlop##
WHEN (betround == ConstBetRoundPreflop) RETURN Raises FORCE
WHEN (betround >  ConstBetRoundPreflop) RETURN me_re_MemRaisesBeforeFlop FORCE
WHEN Others RETURN 0 FORCE

##NumberOfRaisesOnFlop##
WHEN (betround == ConstBetRoundFlop) RETURN Raises FORCE
WHEN (betround >  ConstBetRoundFlop) RETURN me_re_MemRaisesOnFlop FORCE
WHEN Others RETURN 0 FORCE

##NumberOfRaisesOnTurn##
WHEN (betround == ConstBetRoundTurn) RETURN Raises FORCE
WHEN (betround >  ConstBetRoundTurn) RETURN me_re_MemRaisesOnTurn FORCE
WHEN Others RETURN 0 FORCE

##Calculate_Raises##
(me_re_MemRaises + RaisesSinceLastPlay)

##InitRaises##
(BotsActionsOnThisRoundIncludingChecks == 0) ? me_st_MemRaises_RaisesSinceLastPlay :
me_st_MemRaises_Calculate_Raises

##Raises##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ (NOT ismyturn) ? ERROR_Action_History_Only_Valid_On_My_Turn_Most_Favourite_PEBKAC :
// Raises might have been -1 if there were additional blind-posters,
// because nopponentsraising was wrong in that case for old versions
// But this gets now handled perfectly by nopponentstruelyraising.
// But we keep the sanity-checks anyway.
[(me_re_MemRaises < 0) AND (betround == ConstBetRoundPreflop) AND (ncallbets == 1)] ? 
  (ERROR_Raises_Is_Negative__Trying_To_Adapt_In_A_Reasonable_Way + 0) :
[(me_re_MemRaises < 0) AND (betround == ConstBetRoundPreflop) AND (ncallbets > 1)]  ? 
  (ERROR_Raises_Is_Negative__Trying_To_Adapt_In_A_Reasonable_Way + 1) :
// Should not happen postflop, but a sanity-check can't harm.
[(me_re_MemRaises < 0) AND (betround >= ConstBetRoundFlop)] ? 
  (ERROR_Raises_Is_Negative__Trying_To_Adapt_In_A_Reasonable_Way + 0) :
// Otherwise: probably everything ok
me_re_MemRaises

##RaisesBeforeFlop##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ (NumberOfRaisesBeforeFlop > 0)

##RaisesOnFlop##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ (NumberOfRaisesOnFlop > 0)

##RaisesOnTurn##
VerifyHeartbeatIDForBetsCallsChecksRaises
+ (NumberOfRaisesOnTurn > 0)

##RaisesBeforeOurFirstActionThisRoundPostflop##
(nopponentstruelyraising > 0) ? (nopponentstruelyraising - 1) : 0

##AntesPresent##
// First orbit preflop only,
// as this function tries to guess the antes from the bets.
   [(currentbet0 > 0) AND (currentbet0 < sblind) AND (balance0 > 0)]
OR [(currentbet1 > 0) AND (currentbet1 < sblind) AND (balance1 > 0)]
OR [(currentbet2 > 0) AND (currentbet2 < sblind) AND (balance2 > 0)]
OR [(currentbet3 > 0) AND (currentbet3 < sblind) AND (balance3 > 0)]
OR [(currentbet4 > 0) AND (currentbet4 < sblind) AND (balance4 > 0)]
OR [(currentbet5 > 0) AND (currentbet5 < sblind) AND (balance5 > 0)]
OR [(currentbet6 > 0) AND (currentbet6 < sblind) AND (balance6 > 0)]
OR [(currentbet7 > 0) AND (currentbet7 < sblind) AND (balance7 > 0)]
OR [(currentbet8 > 0) AND (currentbet8 < sblind) AND (balance8 > 0)]
OR [(currentbet9 > 0) AND (currentbet9 < sblind) AND (balance9 > 0)]

##NumberOfOpponentsLimpingPreflop##
// First orbit preflop only
// Does not count the user
// Does not count the big-blind, who can't limp
  [(currentbet0 == bblind) AND (userchair != 0) AND (BigBlindChair != 0) ? 1 : 0]
+ [(currentbet1 == bblind) AND (userchair != 1) AND (BigBlindChair != 1) ? 1 : 0]
+ [(currentbet2 == bblind) AND (userchair != 2) AND (BigBlindChair != 2) ? 1 : 0]
+ [(currentbet3 == bblind) AND (userchair != 3) AND (BigBlindChair != 3) ? 1 : 0]
+ [(currentbet4 == bblind) AND (userchair != 4) AND (BigBlindChair != 4) ? 1 : 0]
+ [(currentbet5 == bblind) AND (userchair != 5) AND (BigBlindChair != 5) ? 1 : 0]
+ [(currentbet6 == bblind) AND (userchair != 6) AND (BigBlindChair != 6) ? 1 : 0]
+ [(currentbet7 == bblind) AND (userchair != 7) AND (BigBlindChair != 7) ? 1 : 0]
+ [(currentbet8 == bblind) AND (userchair != 8) AND (BigBlindChair != 8) ? 1 : 0]
+ [(currentbet9 == bblind) AND (userchair != 9) AND (BigBlindChair != 9) ? 1 : 0]

##RaisesBeforeOurFirstAction##
(BotsActionsOnThisRoundIncludingChecks > 0) ? 0 :
(betround > ConstBetRoundPreflop) ? RaisesBeforeOurFirstActionThisRoundPostflop :
nopponentstruelyraising

##RaisesSinceLastPlayOnOurSecondAction##
// If we checked the first time the bettor sits behind us.
[didchec AND (nopponentstruelyraising > 0) ] ? (nopponentstruelyraising - 1) :
[didchec AND (nopponentstruelyraising == 0)] ? 0 :
// Otherwise: either we were the first bettor
// or there was a bet and maybe raises in front of us,
// so all technical "raises" behind us are true raises
nopponentstruelyraising

##RaisesSinceLastPlayAfterOurSecondAction##
// Now all technical raises are true raises, no bettors possible
nopponentstruelyraising

##RaisesSinceLastPlay##
(NOT ismyturn) ? ERROR_Action_History_Only_Valid_On_My_Turn_Most_Favourite_PEBKAC :
(BotsActionsOnThisRoundIncludingChecks == 0) ? RaisesBeforeOurFirstAction :
(BotsActionsOnThisRoundIncludingChecks == 1) ? RaisesSinceLastPlayOnOurSecondAction :
(BotsActionsOnThisRoundIncludingChecks >= 2) ? RaisesSinceLastPlayAfterOurSecondAction :
ERROR_BotsActionsOnThisRound_Out_Of_Range

//*****************************************************************************
//
// OpenPPL - Betsizes and StackSizes - supporting technical functions
//
//*****************************************************************************

##BigBlindCurrentBet##
// Amount in bets (big blinds for preflop)
(bet <= 0) ? ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap :
(BigBlindChair == 0) ? (currentbet0 / bet) :
(BigBlindChair == 1) ? (currentbet1 / bet) :
(BigBlindChair == 2) ? (currentbet2 / bet) :
(BigBlindChair == 3) ? (currentbet3 / bet) :
(BigBlindChair == 4) ? (currentbet4 / bet) :
(BigBlindChair == 5) ? (currentbet5 / bet) :
(BigBlindChair == 6) ? (currentbet6 / bet) :
(BigBlindChair == 7) ? (currentbet7 / bet) :
(BigBlindChair == 8) ? (currentbet8 / bet) :
(BigBlindChair == 9) ? (currentbet9 / bet) :
ERROR_BigBlindChair_Not_Recognized__Check_Your_TableMap

##SmallBlindCurrentBet##
// Amount in bets (big blinds for preflop)
(bet <= 0) ? ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap :
(SmallBlindChair == 0) ? (currentbet0 / bet) :
(SmallBlindChair == 1) ? (currentbet1 / bet) :
(SmallBlindChair == 2) ? (currentbet2 / bet) :
(SmallBlindChair == 3) ? (currentbet3 / bet) :
(SmallBlindChair == 4) ? (currentbet4 / bet) :
(SmallBlindChair == 5) ? (currentbet5 / bet) :
(SmallBlindChair == 6) ? (currentbet6 / bet) :
(SmallBlindChair == 7) ? (currentbet7 / bet) :
(SmallBlindChair == 8) ? (currentbet8 / bet) :
(SmallBlindChair == 9) ? (currentbet9 / bet) :
ERROR_SmallBlindChair_Not_Recognized__Check_Your_TableMap

##MaximumPossibleBetsizeIndollars##
(balance + currentbet)

##SidePotInDollars##
// Money in the side-pot, i.e. the money we don't compete for.
  [(currentbet0 > MaximumPossibleBetsizeIndollars) ? currentbet0 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet1 > MaximumPossibleBetsizeIndollars) ? currentbet1 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet2 > MaximumPossibleBetsizeIndollars) ? currentbet2 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet3 > MaximumPossibleBetsizeIndollars) ? currentbet3 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet4 > MaximumPossibleBetsizeIndollars) ? currentbet4 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet5 > MaximumPossibleBetsizeIndollars) ? currentbet5 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet6 > MaximumPossibleBetsizeIndollars) ? currentbet6 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet7 > MaximumPossibleBetsizeIndollars) ? currentbet7 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet8 > MaximumPossibleBetsizeIndollars) ? currentbet8 - MaximumPossibleBetsizeIndollars : 0]
+ [(currentbet9 > MaximumPossibleBetsizeIndollars) ? currentbet9 - MaximumPossibleBetsizeIndollars : 0]

##SidePot##
// Money in the side-pot, i.e. the money we don't compete for (measured in big blinds)
(bblind > 0) ? (SidePotInDollars / bblind) : 0

##MaxStillToActStackSizeAfterSmallBlind##
// Only one player behind SB, so it is easy
// Per definition for first orbit preflop only.
BigBlindStartingStackSize

##MaxStillToActStackSizeAfterButton##
// Per definition for first orbit preflop only
SmallBlindStartingStackSize > MaxStillToActStackSizeAfterSmallBlind ?
  SmallBlindStartingStackSize : MaxStillToActStackSizeAfterSmallBlind

##MaxStillToActStackSizeAfterCutOff##
// Per definition for first orbit preflop only
ButtonStartingStackSize > MaxStillToActStackSizeAfterButton ?
  ButtonStartingStackSize : MaxStillToActStackSizeAfterButton

##MaxStillToActStackSizeAfterMiddlePosition3##
// Per definition for first orbit preflop only
CutOffStartingStackSize > MaxStillToActStackSizeAfterCutOff?
  CutOffStartingStackSize : MaxStillToActStackSizeAfterCutOff

##MaxStillToActStackSizeAfterMiddlePosition2##
// Per definition for first orbit preflop only
MiddlePosition3StartingStackSize > MaxStillToActStackSizeAfterMiddlePosition3 ?
  MiddlePosition3StartingStackSize : MaxStillToActStackSizeAfterMiddlePosition3

##MaxStillToActStackSizeAfterMiddlePosition1##
// Per definition for first orbit preflop only
MiddlePosition2StartingStackSize > MaxStillToActStackSizeAfterMiddlePosition2 ?
  MiddlePosition2StartingStackSize : MaxStillToActStackSizeAfterMiddlePosition2

##MaxStillToActStackSizeAfterEarlyPosition3##
// Per definition for first orbit preflop only
MiddlePosition1StartingStackSize > MaxStillToActStackSizeAfterMiddlePosition1 ?
  MiddlePosition1StartingStackSize : MaxStillToActStackSizeAfterMiddlePosition1

##MaxStillToActStackSizeAfterEarlyPosition2##
// Per definition for first orbit preflop only
EarlyPosition3StartingStackSize > MaxStillToActStackSizeAfterEarlyPosition3 ?
  EarlyPosition3StartingStackSize : MaxStillToActStackSizeAfterEarlyPosition3

##MaxStillToActStackSizeAfterEarlyPosition1##
// Per definition for first orbit preflop only
EarlyPosition2StartingStackSize > MaxStillToActStackSizeAfterEarlyPosition2 ?
  EarlyPosition2StartingStackSize : MaxStillToActStackSizeAfterEarlyPosition2

##MinStillToActStackSizeAfterSmallBlind##
// Only one player behind SB, so it is easy
BigBlindStartingStackSize

##MinStillToActStackSizeAfterButton##
SmallBlindStartingStackSize < MinStillToActStackSizeAfterSmallBlind ?
  SmallBlindStartingStackSize : MinStillToActStackSizeAfterSmallBlind

##MinStillToActStackSizeAfterCutOff##
ButtonStartingStackSize < MinStillToActStackSizeAfterButton ?
  ButtonStartingStackSize : MinStillToActStackSizeAfterButton

##MinStillToActStackSizeAfterMiddlePosition3##
CutOffStartingStackSize < MinStillToActStackSizeAfterCutOff ?
  CutOffStartingStackSize : MinStillToActStackSizeAfterCutOff

##MinStillToActStackSizeAfterMiddlePosition2##
MiddlePosition3StartingStackSize < MinStillToActStackSizeAfterMiddlePosition3 ?
  MiddlePosition3StartingStackSize : MinStillToActStackSizeAfterMiddlePosition3

##MinStillToActStackSizeAfterMiddlePosition1##
MiddlePosition2StartingStackSize < MinStillToActStackSizeAfterMiddlePosition2 ?
  MiddlePosition2StartingStackSize : MinStillToActStackSizeAfterMiddlePosition2

##MinStillToActStackSizeAfterEarlyPosition3##
MiddlePosition1StartingStackSize < MinStillToActStackSizeAfterMiddlePosition1 ?
  MiddlePosition1StartingStackSize : MinStillToActStackSizeAfterMiddlePosition1

##MinStillToActStackSizeAfterEarlyPosition2##
EarlyPosition3StartingStackSize < MinStillToActStackSizeAfterEarlyPosition3 ?
  EarlyPosition3StartingStackSize : MinStillToActStackSizeAfterEarlyPosition3

##MinStillToActStackSizeAfterEarlyPosition1##
EarlyPosition2StartingStackSize < MinStillToActStackSizeAfterEarlyPosition2 ?
  EarlyPosition2StartingStackSize : MinStillToActStackSizeAfterEarlyPosition2

##InitMaxOpponentStackSize##
(betround == ConstBetRoundPreflop) ? me_st_MaxOpponentStackSize_MaxOpponentStackSizeCalculation : 
HINT_Nothing_To_Do_But_All_OK

##InitMinOpponentStackSize##
(betround == ConstBetRoundPreflop) ? me_st_MinOpponentStackSize_MinOpponentStackSizeCalculation :
HINT_Nothing_To_Do_But_All_OK

##MaxOpponentStackSizeCalculation##
(bblind <= 0) ? ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap :
(balance_rank0 == (balance + currentbet)) ? (balance_rank1 / bblind) : (balance_rank0 / bblind)

##MinOpponentStackSizeCalculation##
(bblind <= 0) ? ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap :
[ 1 / bblind *
[ nplayersdealt == 10 ?
    (balance_rank9 == (balance + currentbet) ? balance_rank8 : balance_rank9) :
  nplayersdealt == 9 ?
    (balance_rank8 == (balance + currentbet) ? balance_rank7 : balance_rank8) :
  nplayersdealt == 8 ?
    (balance_rank7 == (balance + currentbet) ? balance_rank6 : balance_rank7) :
  nplayersdealt == 7 ?
    (balance_rank6 == (balance + currentbet) ? balance_rank5 : balance_rank6) :
  nplayersdealt == 6 ?
    (balance_rank5 == (balance + currentbet) ? balance_rank4 : balance_rank5) :
  nplayersdealt == 5 ?
    (balance_rank4 == (balance + currentbet) ? balance_rank3 : balance_rank4) :
  nplayersdealt == 4 ?
    (balance_rank3 == (balance + currentbet) ? balance_rank2 : balance_rank3) :
  nplayersdealt == 3 ?
    (balance_rank2 == (balance + currentbet) ? balance_rank1 : balance_rank2) :
  nplayersdealt == 2 ?
    (balance_rank1 == (balance + currentbet) ? balance_rank0 : balance_rank1) :
ERROR_No_Opponents_Detected__Check_Your_TableMap]]

##OpponentsWithHigherStack##
// No need to tinker with memory symbols here,
// this logic is valid for all betting rounds.
  (((balance0 + currentbet0) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance1 + currentbet1) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance2 + currentbet2) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance3 + currentbet3) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance4 + currentbet4) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance5 + currentbet5) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance6 + currentbet6) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance7 + currentbet7) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance8 + currentbet8) > MaximumPossibleBetsizeIndollars) ? 1: 0)
+ (((balance9 + currentbet9) > MaximumPossibleBetsizeIndollars) ? 1: 0)

##CalculateStartingStackSize##
// Precondition: first hand, preflop
(bblind > 0) ? ((currentbet + balance + ante) / bblind) : ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap

##InitStartingStackSize##
((handsplayed == 0 OR StartingStackSize == 0) AND (betround == ConstBetRoundPreflop)) ?
  me_st_MemStartingStackSize_CalculateStartingStackSize : HINT_Nothing_To_Do_But_All_OK

##StartingStackSize##
me_re_MemStartingStackSize

##CalculateStartingChips##
// Precondition: first hand, preflop
(bblind > 0) ? (currentbet + balance) : ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap

##InitStartingChips##
((handsplayed == 0 OR StartingChips == 0) AND (betround == ConstBetRoundPreflop)) ?
  me_st_MemStartingChips_CalculateStartingChips : HINT_Nothing_To_Do_But_All_OK

##StartingChips##
me_re_MemStartingChips

//*****************************************************************************
//
// OpenPPL - Betsizes and StackSizes
//
//*****************************************************************************

##DollarsToCallForMisScrapedEverything##
// My balance and opponents bet miss-scraped
// For NL and Pl assume a min-raise which must be about as much as my bet
// The ability to check got already excluded
(isnl OR ispl) ? currentbet : bet

##DollarsToCallForMisScrapedUserBalance##
// My balance miss-scraped as 0
(call > 0) ? call : DollarsToCallForMisScrapedEverything

##DollarsToCallForMisScrapedOpponentBet##
// Opponents bet must be miss-scraped
// Incorrect amount to call despite I already acted.
// Lets assume a min-raise, which must be at least as much as my bet (NL / PL)
isfl ? bet : currentbet

##DollarsToCall##
// Effective DollarsToCall could go wrong, if our balance got miss-scraped
// (Our balance must be always > 0 if it is our turn)
// Therefore we create multiple functions for multiple cases of bad input.
(ismyturn AND balance <= 0) ? DollarsToCallForMisScrapedUserBalance :
// Preflop and I already did act in a raised pot, but nothing to call
((betround == ConstBetRoundPreflop) AND (ncurrentbets >= 1.01) AND (call <= 0)) ? DollarsToCallForMisScrapedOpponentBet :
// Preflop and I am not big-blind and there is nothing to call
((betround == ConstBetRoundPreflop) AND (ncurrentbets < 1) AND (call <= 0)) ? DollarsToCallForMisScrapedOpponentBet :
// Postflop and I already did act, but nothing to call
((betround > ConstBetRoundPreflop) AND (ncurrentbets > 0) AND (call <= 0))  ? DollarsToCallForMisScrapedOpponentBet :
// The normal case (including correct and incorrect abilities to check)
(call <= balance) ? call : balance

##AmountToCall##
(bblind > 0) ? (DollarsToCall / bblind) : ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap

##BetSize##
ncallbets

##BigBlindSize##
bet1

##MaxOpponentStackSize##
me_re_MaxOpponentStackSize

##MaxOpponentsLeftStackSize##
// We believe MaxOpponentsLeftStackSize is better than MaxStacksizeOfActiveOpponents
// http://www.maxinmontreal.com/forums/viewtopic.php?f=297&t=18924
MaxStacksizeOfActiveOpponents

##MaxStacksizeOfActiveOpponents##
(bblind > 0) ? 
(stack0 == balance ? stack1/bblind : stack0/bblind) :
ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap

##EffectiveMaxStacksizeOfActiveOpponents##
(StackSize <= MaxStacksizeOfActiveOpponents) ? StackSize : MaxStacksizeOfActiveOpponents

##MaxStillToActStackSize##
// Per definition for first orbit preflop only
userchair == BigBlindChair        ? 0 :
userchair == SmallBlindChair      ? MaxStillToActStackSizeAfterSmallBlind      :
userchair == ButtonChair          ? MaxStillToActStackSizeAfterButton          :
userchair == CutOffChair          ? MaxStillToActStackSizeAfterCutOff          :
userchair == MiddlePosition3Chair ? MaxStillToActStackSizeAfterMiddlePosition3 :
userchair == MiddlePosition2Chair ? MaxStillToActStackSizeAfterMiddlePosition2 :
userchair == MiddlePosition1Chair ? MaxStillToActStackSizeAfterMiddlePosition1 :
userchair == EarlyPosition3Chair  ? MaxStillToActStackSizeAfterEarlyPosition3  :
userchair == EarlyPosition2Chair  ? MaxStillToActStackSizeAfterEarlyPosition2  :
userchair == EarlyPosition1Chair  ? MaxStillToActStackSizeAfterEarlyPosition1  :
HINT_Something_Is_Wrong__It_Seems_You_Are_Not_Even_Seated

##MinOpponentStackSize##
me_re_MinOpponentStackSize

##MinStillToActStackSize##
userchair == BigBlindChair        ? 0:
userchair == SmallBlindChair      ? MinStillToActStackSizeAfterSmallBlind      :
userchair == ButtonChair          ? MinStillToActStackSizeAfterButton          :
userchair == CutOffChair          ? MinStillToActStackSizeAfterCutOff          :
userchair == MiddlePosition3Chair ? MinStillToActStackSizeAfterMiddlePosition3 :
userchair == MiddlePosition2Chair ? MinStillToActStackSizeAfterMiddlePosition2 :
userchair == MiddlePosition1Chair ? MinStillToActStackSizeAfterMiddlePosition1 :
userchair == EarlyPosition3Chair  ? MinStillToActStackSizeAfterEarlyPosition3  :
userchair == EarlyPosition2Chair  ? MinStillToActStackSizeAfterEarlyPosition2  :
userchair == EarlyPosition1Chair  ? MinStillToActStackSizeAfterEarlyPosition1  :
HINT_Something_Is_Wrong__It_Seems_You_Are_Not_Even_Seated

##PotSize##
// Considering effective potside
(bblind > 0) ? (pot / bblind) - SidePot: ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap

##StackSize##
(bblind > 0) ? (balance / bblind) : ERROR_Blinds_Not_Recognized_Correctly__Check_Your_TableMap

##StackSizeAtBeginningOfCurrentRound##
StackSize + TotalInvestedThisRound

##TotalInvested##
WHEN (betround == ConstBetRoundPreflop) RETURN (Ante + ncurrentbets) FORCE
WHEN (betround == ConstBetRoundFlop)    RETURN (Ante + nbetsround1 + ncurrentbets) FORCE
WHEN (betround == ConstBetRoundTurn)    RETURN (Ante + nbetsround1 + nbetsround2 + ncurrentbets) FORCE
WHEN (betround == ConstBetRoundRiver)   RETURN (Ante + nbetsround1 + nbetsround2 + nbetsround3 + ncurrentbets) FORCE 
WHEN Others RETURN ERROR_Betround_Out_Of_Range FORCE

##TotalInvestedThisRound##
(betround == ConstBetRoundPreflop) ? (ncurrentbets + Ante) : ncurrentbets

//*****************************************************************************
//
// OpenPPL - Players and Opponents
//
//*****************************************************************************

##HandIsHeadsup##
TwoPlayersCompetingForThisPot

##TableIsHeadsup##
WHEN istournament AND OnlyTwoPlayersLeftAtTournamentTable RETURN True FORCE
WHEN (NOT istournament) AND (nplayersdealt = 2) RETURN True FORCE

##TwoPlayersCompetingForThisPot##
// Just to create some verbosity in HandIsHeadsup
WHEN nplayersplaying = 2 RETURN True FORCE

##OnlyTwoPlayersLeftAtTournamentTable##
// Just to create some verbosity in HandIsHeadsup
WHEN (not istournament) RETURN False FORCE
// Players in tournaments get always dealt even if they are sitting out.
// http://www.maxinmontreal.com/forums/viewtopic.php?f=297&t=19778
// So we check seated players
WHEN (nplayersseated = 2) RETURN True FORCE

##PlayersAtStartOfThisRound##
(betround == ConstBetRoundPreflop) ? nplayersround1 :
(betround == ConstBetRoundFlop)    ? nplayersround2 :
(betround == ConstBetRoundTurn)    ? nplayersround3 :
(betround == ConstBetRoundRiver)   ? nplayersround4 :
ERROR_Betround_Out_Of_Range

##Opponents##
OpponentsLeft

##OpponentsAtTable##
nopponentsseated

##NumberOfOpponentsAllin##
(Opponents>1 OR (Opponents==1 AND AmountToCall<StackSize))? Opponents_SumAllinBits:
(Opponents==1 AND AmountToCall==StackSize)? 1:
0
   
##Casino_Moves_Allinbets_Immediatelly_To_The_Mainpot##
// Some casinos don't display the bets of players who are allin,
// but move them immediately to the main-pot (and/or sitepots)
// so we can no longer assume that they have a positive bet.
// http://www.maxinmontreal.com/forums/viewtopic.php?f=156&t=15493
sitename$ongame

##OpponentIsAllin##
NumberOfOpponentsAllin > 0

##Opponents_SumAllinBits##
`Opponents_AllinBits

##Opponents_AllinBits##
[(betround == ConstBetRoundPreflop) AND NOT Casino_Moves_Allinbets_Immediatelly_To_The_Mainpot] ?
// Player must be playing, his balance must be 0 and he must have a positive bet.
[0
|(((opponentsplayingbits & (1 << 0)) AND (currentbet0 > 0) AND (balance0 == 0)) ? 1 << 0 : 0)
|(((opponentsplayingbits & (1 << 1)) AND (currentbet1 > 0) AND (balance1 == 0)) ? 1 << 1 : 0)
|(((opponentsplayingbits & (1 << 2)) AND (currentbet2 > 0) AND (balance2 == 0)) ? 1 << 2 : 0)
|(((opponentsplayingbits & (1 << 3)) AND (currentbet3 > 0) AND (balance3 == 0)) ? 1 << 3 : 0)
|(((opponentsplayingbits & (1 << 4)) AND (currentbet4 > 0) AND (balance4 == 0)) ? 1 << 4 : 0)
|(((opponentsplayingbits & (1 << 5)) AND (currentbet5 > 0) AND (balance5 == 0)) ? 1 << 5 : 0)
|(((opponentsplayingbits & (1 << 6)) AND (currentbet6 > 0) AND (balance6 == 0)) ? 1 << 6 : 0)
|(((opponentsplayingbits & (1 << 7)) AND (currentbet7 > 0) AND (balance7 == 0)) ? 1 << 7 : 0)
|(((opponentsplayingbits & (1 << 8)) AND (currentbet8 > 0) AND (balance8 == 0)) ? 1 << 8 : 0)
|(((opponentsplayingbits & (1 << 9)) AND (currentbet9 > 0) AND (balance9 == 0)) ? 1 << 9 : 0)
]
:
// Player must be playing, his balance must be 0
// His bet might or might not be > 0 (so it does not get checked),
// because the player could be gone allin in a previous betting round
// or he plays at a casino where his chips get immediatelly moved to the main pot. 
[0
|(((opponentsplayingbits & (1 << 0)) AND balance0 == 0) ? 1 << 0 : 0)
|(((opponentsplayingbits & (1 << 1)) AND balance1 == 0) ? 1 << 1 : 0)
|(((opponentsplayingbits & (1 << 2)) AND balance2 == 0) ? 1 << 2 : 0)
|(((opponentsplayingbits & (1 << 3)) AND balance3 == 0) ? 1 << 3 : 0)
|(((opponentsplayingbits & (1 << 4)) AND balance4 == 0) ? 1 << 4 : 0)
|(((opponentsplayingbits & (1 << 5)) AND balance5 == 0) ? 1 << 5 : 0)
|(((opponentsplayingbits & (1 << 6)) AND balance6 == 0) ? 1 << 6 : 0)
|(((opponentsplayingbits & (1 << 7)) AND balance7 == 0) ? 1 << 7 : 0)
|(((opponentsplayingbits & (1 << 8)) AND balance8 == 0) ? 1 << 8 : 0)
|(((opponentsplayingbits & (1 << 9)) AND balance9 == 0) ? 1 << 9 : 0)
]

##OpponentsLeft##
// Does also consider players who are allin 
// (contrary to Shankys, who consider players allin in this round, but not from previous rounds).
nopponentsplaying

##OpponentsOnFlop##
(nplayersround2 - 1)

##OpponentsOnTurn##
(nplayersround3 - 1)

##OpponentsOnRiver##
(nplayersround4 - 1)

##OpponentsWithLowerStack##
  (((balance0 + currentbet0) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0001) ? 1:0)
+ (((balance1 + currentbet1) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0002) ? 1:0)
+ (((balance2 + currentbet2) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0004) ? 1:0)
+ (((balance3 + currentbet3) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0008) ? 1:0)
+ (((balance4 + currentbet4) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0010) ? 1:0)
+ (((balance5 + currentbet5) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0020) ? 1:0)
+ (((balance6 + currentbet6) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0040) ? 1:0)
+ (((balance7 + currentbet7) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0080) ? 1:0)
+ (((balance8 + currentbet8) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0100) ? 1:0)
+ (((balance9 + currentbet9) < MaximumPossibleBetsizeIndollars) AND (playersseatedbits & 0x0200) ? 1:0)

##StillToActPreflop##
// Precondition: first action, but this gets checked in StillToAct
InBigBlind ? 0 :
InSmallBlind ? 1 :
// Not in the blinds
(MissingSmallBlind > 0) ? (nchairsdealtleft + 1) :
(nchairsdealtleft + 2)

##StillToActPostflop##
// Precondition: first action, but this gets checked in StillToAct
((OpponentsLeft + 1) - betposition)

##StillToAct##
(BotsActionsOnThisRoundIncludingChecks > 0) ? HINT_StillToAct_Is_Only_Valid_On_First_Orbit :
((betround == ConstBetRoundPreflop) AND (BotsActionsOnThisRoundIncludingChecks == 0)) ? StillToActPreflop:
((betround != ConstBetRoundPreflop) AND (BotsActionsOnThisRoundIncludingChecks == 0)) ? StillToActPostflop:
0

//*****************************************************************************
//
// OpenPPL - Position Symbols
//
//*****************************************************************************

// Standard PPL accepts two spellings for the position symbols
// "In BigBlind" and "InBigBlind", "In Button" and "InButton", ...
// Our parser is able to ignore the fillerword "In ",
// but to be more user-friendly and to simplify the converter (less error-handling)
// we decided to provide both forms of naming in the library.

##SmallBlind##
// Small blind missing, therefore we can't be small blind
MissingSmallBlind ? False :
// 3 or more handed, normal blinds
   ((NOT TableIsHeadsup) AND (dealposition == 1))
// Headsup, reversed blinds
OR (TableIsHeadsup AND (dealposition == 2))

##BigBlind##
// Missing small blind, big blind is the first dealt player
MissingSmallBlind ? (dealposition == 1) :
// 3 or more handed, normal blinds
   ((NOT TableIsHeadsup) AND (dealposition == 2))
// Headsup, reversed blinds
OR ((TableIsHeadsup) AND (dealposition == 1))

##Button##
// If the game in not 10-handed, some positions would be both "normal" and in the blinds.
// E.g. for a 9-handed game big-blind would also be counted as EarlyPosition1.
// Therefore we check for "Not InTheBlinds", except for button,
// because "InButton" makes sense even if the game is headsup.
(dealposition == nplayersdealt)

##CutOff##
[(dealposition == nplayersdealt - 1) AND NOT InTheBlinds]

##MiddlePosition3##
[(dealposition == nplayersdealt - 2) AND NOT InTheBlinds]

##MiddlePosition2##
[(dealposition == nplayersdealt - 3) AND NOT InTheBlinds]

##MiddlePosition1##
[(dealposition == nplayersdealt - 4) AND NOT InTheBlinds]

##EarlyPosition3##
[(dealposition == nplayersdealt - 5) AND NOT InTheBlinds]

##EarlyPosition2##
[(dealposition == nplayersdealt - 6) AND NOT InTheBlinds]

##EarlyPosition1##
[(dealposition == nplayersdealt - 7) AND NOT InTheBlinds]

##UTG##
// Under the gun - first to act preflop, 
// independent of the players at the table (at least 3).
// This symbols is especially useful to sitout 
// after the last hand of a session (before the next blind).
MissingSmallBlind ? (dealposition == 2) :
(dealposition == 3)

##InSmallBlind##
SmallBlind

##InBigBlind##
BigBlind

##TheBlinds##
// To be used: In TheBlinds
InTheBlinds

##InTheBlinds##
(InSmallBlind OR InBigBlind)

##EarlyPosition##
InEarlyPosition

##InEarlyPosition##
(InEarlyPosition1 OR InEarlyPosition2 OR InEarlyPosition3)

##MiddlePosition##
InMiddlePosition

##InMiddlePosition##
(InMiddlePosition1 OR InMiddlePosition2 OR InMiddlePosition3)

##LatePosition##
InLatePosition

##InLatePosition##
(InCutOff OR InButton)

##InButton##
Button

##InCutOff##
CutOff

##InMiddlePosition3##
MiddlePosition3

##InMiddlePosition2##
MiddlePosition2

##InMiddlePosition1##
MiddlePosition1

##InEarlyPosition3##
EarlyPosition3

##InEarlyPosition2##
EarlyPosition2

##InEarlyPosition1##
EarlyPosition1

##InUTG##
UTG

##TrueDealPositionOfBigBlind##
// http://www.maxinmontreal.com/forums/viewtopic.php?f=257&t=19377
WHEN TableIsHeadsup RETURN 1 FORCE
WHEN MissingSmallBlind RETURN 1 FORCE
WHEN Others RETURN 2 FORCE

##BigBlindChair##
ac_dealpos0 == TrueDealPositionOfBigBlind ? 0 :
ac_dealpos1 == TrueDealPositionOfBigBlind ? 1 :
ac_dealpos2 == TrueDealPositionOfBigBlind ? 2 :
ac_dealpos3 == TrueDealPositionOfBigBlind ? 3 :
ac_dealpos4 == TrueDealPositionOfBigBlind ? 4 :
ac_dealpos5 == TrueDealPositionOfBigBlind ? 5 :
ac_dealpos6 == TrueDealPositionOfBigBlind ? 6 :
ac_dealpos7 == TrueDealPositionOfBigBlind ? 7 :
ac_dealpos8 == TrueDealPositionOfBigBlind ? 8 :
ac_dealpos9 == TrueDealPositionOfBigBlind ? 9 :
ERROR_BigBlindChair_Not_Recognized__Check_Your_TableMap
  
##SmallBlindChair##
MissingSmallBlind ? HINT_There_Is_No_SmallNlind_In_This_Game :
ac_dealpos0 == 1 ? 0 :
ac_dealpos1 == 1 ? 1 :
ac_dealpos2 == 1 ? 2 :
ac_dealpos3 == 1 ? 3 :
ac_dealpos4 == 1 ? 4 :
ac_dealpos5 == 1 ? 5 :
ac_dealpos6 == 1 ? 6 :
ac_dealpos7 == 1 ? 7 :
ac_dealpos8 == 1 ? 8 :
ac_dealpos9 == 1 ? 9 :
ERROR_SmallBlindChair_Not_Recognized__Check_Your_TableMap

##ButtonChair##
// We ignore the case of headsup,
// where button = small blind or button = big blind,
// as this seems to be different for each casino.
// For us: button = bigblind, if the game is headsup.
ac_dealpos0 == nplayersdealt ? 0 :
ac_dealpos1 == nplayersdealt ? 1 :
ac_dealpos2 == nplayersdealt ? 2 :
ac_dealpos3 == nplayersdealt ? 3 :
ac_dealpos4 == nplayersdealt ? 4 :
ac_dealpos5 == nplayersdealt ? 5 :
ac_dealpos6 == nplayersdealt ? 6 :
ac_dealpos7 == nplayersdealt ? 7 :
ac_dealpos8 == nplayersdealt ? 8 :
ac_dealpos9 == nplayersdealt ? 9 :
ERROR_ButtonChair_Not_Recognized__Check_Your_TableMap

##CutOffChair##
// We have to make sure, that the userchair in question is not a blind,
// which would be the case for CutOff, if the game was 3-handed.
// For 3-handed games "CutOff" = BigBlind, but blinds take priority.
// We could test for dealposition > 2, but counting players is more simple.
(nplayersdealt <= 3) ? HINT_CutOff_Does_Not_Exist :
ac_dealpos0 == (nplayersdealt - 1) ? 0 :
ac_dealpos1 == (nplayersdealt - 1) ? 1 :
ac_dealpos2 == (nplayersdealt - 1) ? 2 :
ac_dealpos3 == (nplayersdealt - 1) ? 3 :
ac_dealpos4 == (nplayersdealt - 1) ? 4 :
ac_dealpos5 == (nplayersdealt - 1) ? 5 :
ac_dealpos6 == (nplayersdealt - 1) ? 6 :
ac_dealpos7 == (nplayersdealt - 1) ? 7 :
ac_dealpos8 == (nplayersdealt - 1) ? 8 :
ac_dealpos9 == (nplayersdealt - 1) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##MiddlePosition3Chair##
(nplayersdealt <= 4) ? HINT_MiddlePosition3_Does_Not_Exist :
ac_dealpos0 == (nplayersdealt - 2) ? 0 :
ac_dealpos1 == (nplayersdealt - 2) ? 1 :
ac_dealpos2 == (nplayersdealt - 2) ? 2 :
ac_dealpos3 == (nplayersdealt - 2) ? 3 :
ac_dealpos4 == (nplayersdealt - 2) ? 4 :
ac_dealpos5 == (nplayersdealt - 2) ? 5 :
ac_dealpos6 == (nplayersdealt - 2) ? 6 :
ac_dealpos7 == (nplayersdealt - 2) ? 7 :
ac_dealpos8 == (nplayersdealt - 2) ? 8 :
ac_dealpos9 == (nplayersdealt - 2) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##MiddlePosition2Chair##
(nplayersdealt <= 5) ? HINT_MiddlePosition2_Does_Not_Exist :
ac_dealpos0 == (nplayersdealt - 3) ? 0 :
ac_dealpos1 == (nplayersdealt - 3) ? 1 :
ac_dealpos2 == (nplayersdealt - 3) ? 2 :
ac_dealpos3 == (nplayersdealt - 3) ? 3 :
ac_dealpos4 == (nplayersdealt - 3) ? 4 :
ac_dealpos5 == (nplayersdealt - 3) ? 5 :
ac_dealpos6 == (nplayersdealt - 3) ? 6 :
ac_dealpos7 == (nplayersdealt - 3) ? 7 :
ac_dealpos8 == (nplayersdealt - 3) ? 8 :
ac_dealpos9 == (nplayersdealt - 3) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##MiddlePosition1Chair##
(nplayersdealt <= 6) ? HINT_MiddlePosition1_Does_Not_Exist :
ac_dealpos0 == (nplayersdealt - 4) ? 0 :
ac_dealpos1 == (nplayersdealt - 4) ? 1 :
ac_dealpos2 == (nplayersdealt - 4) ? 2 :
ac_dealpos3 == (nplayersdealt - 4) ? 3 :
ac_dealpos4 == (nplayersdealt - 4) ? 4 :
ac_dealpos5 == (nplayersdealt - 4) ? 5 :
ac_dealpos6 == (nplayersdealt - 4) ? 6 :
ac_dealpos7 == (nplayersdealt - 4) ? 7 :
ac_dealpos8 == (nplayersdealt - 4) ? 8 :
ac_dealpos9 == (nplayersdealt - 4) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##EarlyPosition3Chair##
(nplayersdealt <= 7) ? HINT_EarlyPosition3_Does_Not_Exist :
ac_dealpos0 == (nplayersdealt - 5) ? 0 :
ac_dealpos1 == (nplayersdealt - 5) ? 1 :
ac_dealpos2 == (nplayersdealt - 5) ? 2 :
ac_dealpos3 == (nplayersdealt - 5) ? 3 :
ac_dealpos4 == (nplayersdealt - 5) ? 4 :
ac_dealpos5 == (nplayersdealt - 5) ? 5 :
ac_dealpos6 == (nplayersdealt - 5) ? 6 :
ac_dealpos7 == (nplayersdealt - 5) ? 7 :
ac_dealpos8 == (nplayersdealt - 5) ? 8 :
ac_dealpos9 == (nplayersdealt - 5) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##EarlyPosition2Chair##
(nplayersdealt <= 8) ? HINT_EarlyPosition2_Does_Not_Exist :
(ac_dealpos0 == (nplayersdealt - 6)) ? 0 :
(ac_dealpos1 == (nplayersdealt - 6)) ? 1 :
(ac_dealpos2 == (nplayersdealt - 6)) ? 2 :
(ac_dealpos3 == (nplayersdealt - 6)) ? 3 :
(ac_dealpos4 == (nplayersdealt - 6)) ? 4 :
(ac_dealpos5 == (nplayersdealt - 6)) ? 5 :
(ac_dealpos6 == (nplayersdealt - 6)) ? 6 :
(ac_dealpos7 == (nplayersdealt - 6)) ? 7 :
(ac_dealpos8 == (nplayersdealt - 6)) ? 8 :
(ac_dealpos9 == (nplayersdealt - 6)) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##EarlyPosition1Chair##
(nplayersdealt <= 9) ? HINT_EarlyPosition1_Does_Not_Exist :
ac_dealpos0 == (nplayersdealt - 7) ? 0 :
ac_dealpos1 == (nplayersdealt - 7) ? 1 :
ac_dealpos2 == (nplayersdealt - 7) ? 2 :
ac_dealpos3 == (nplayersdealt - 7) ? 3 :
ac_dealpos4 == (nplayersdealt - 7) ? 4 :
ac_dealpos5 == (nplayersdealt - 7) ? 5 :
ac_dealpos6 == (nplayersdealt - 7) ? 6 :
ac_dealpos7 == (nplayersdealt - 7) ? 7 :
ac_dealpos8 == (nplayersdealt - 7) ? 8 :
ac_dealpos9 == (nplayersdealt - 7) ? 9 :
ERROR_THIS_SHOULD_NOT_HAPPEN__THERE_SEEMS_TO_BE_A_PROBLEM_IN_THE_LIBRARY

##DealPositionLastRaiser##
// This function does also count blind-raisers.
(AggressorChair == 0) ? ac_dealpos0 :
(AggressorChair == 1) ? ac_dealpos1 :
(AggressorChair == 2) ? ac_dealpos2 :
(AggressorChair == 3) ? ac_dealpos3 :
(AggressorChair == 4) ? ac_dealpos4 :
(AggressorChair == 5) ? ac_dealpos5 :
(AggressorChair == 6) ? ac_dealpos6 :
(AggressorChair == 7) ? ac_dealpos7 :
(AggressorChair == 8) ? ac_dealpos8 :
(AggressorChair == 9) ? ac_dealpos9 :
HINT_There_Are_No_True_Raisers

##EarlyPosition1Calling##
(callbits1 >> EarlyPosition1Chair) & 1 == 1

##EarlyPosition2Calling##
(callbits1 >> EarlyPosition2Chair) & 1 == 1

##EarlyPosition3Calling##
(callbits1 >> EarlyPosition3Chair) & 1 == 1

##MiddlePosition1Calling##
(callbits1 >> MiddlePosition1Chair) & 1 == 1

##MiddlePosition2Calling##
(callbits1 >> MiddlePosition2Chair) & 1 == 1

##MiddlePosition3Calling##
(callbits1 >> MiddlePosition3Chair) & 1 == 1

##CutOffCalling##
(callbits1 >> CutOffChair) & 1 == 1

##ButtonCalling##
(callbits1 >> ButtonChair) & 1 == 1

##SmallBlindCalling##
(callbits1 >> SmallBlindChair) & 1 == 1

##BigBlindCalling##
(callbits1 >> BigBlindChair) & 1 == 1

##EarlyPosition1Raising##
[(raisbits1 >> EarlyPosition1Chair) & 1 == 1]

##EarlyPosition2Raising##
[(raisbits1 >> EarlyPosition2Chair) & 1 == 1]

##EarlyPosition3Raising##
[(raisbits1 >> EarlyPosition3Chair) & 1 == 1]

##MiddlePosition1Raising##
[(raisbits1 >> MiddlePosition1Chair) & 1 == 1]

##MiddlePosition2Raising##
[(raisbits1 >> MiddlePosition2Chair) & 1 == 1]

##MiddlePosition3Raising##
[(raisbits1 >> MiddlePosition3Chair) & 1 == 1]

##CutOffRaising##
[(raisbits1 >> CutOffChair) & 1 == 1]

##ButtonRaising##
[(raisbits1 >> ButtonChair) & 1 == 1]

##SmallBlindRaising##
    [(raisbits1 >> SmallBlindChair) & 1 == 1]
AND [SmallBlindCurrentBet >= 1.01]

##BigBlindRaising##
    [(raisbits1 >> BigBlindChair) & 1 == 1]
AND [BigBlindCurrentBet >= 1.01]

##FirstCallerPosition##
// We have to search starting from early positions,
// as we want to detect the first one.
EarlyPosition1Calling  ? 9 :
EarlyPosition2Calling  ? 8 :
EarlyPosition3Calling  ? 7 :
MiddlePosition1Calling ? 6 :
MiddlePosition2Calling ? 5 :
MiddlePosition3Calling ? 4 :
CutOffCalling          ? 3 :
ButtonCalling          ? 2 :
SmallBlindCalling      ? 1 :
// Can't be big blind (0), as it is for the first orbit preflop only
HINT_No_FirstCaller

##FirstRaiserPosition##
// We have to search starting from early positions,
// as we want to detect the first one.
EarlyPosition1Raising  ? 9 :
EarlyPosition2Raising  ? 8 :
EarlyPosition3Raising  ? 7 :
MiddlePosition1Raising ? 6 :
MiddlePosition2Raising ? 5 :
MiddlePosition3Raising ? 4 :
CutOffRaising          ? 3 :
ButtonRaising          ? 2 :
SmallBlindRaising ? 1 :
// Can't be big blind (0), as it is for the first orbit preflop only
HINT_No_FirstRaiser

##LastCallerPosition##
// Can't be big blind (0), as it is for the first orbit preflop only
SmallBlindCalling      ? 1 :
ButtonCalling          ? 2 :
CutOffCalling          ? 3 :
MiddlePosition3Calling ? 4 :
MiddlePosition2Calling ? 5 :
MiddlePosition1Calling ? 6 :
EarlyPosition3Calling  ? 7 :
EarlyPosition2Calling  ? 8 :
EarlyPosition1Calling  ? 9 :
HINT_No_LastCaller

##LastRaiserPosition##
// Handling the case of blind-raisers only first
[(betround == ConstBetRoundPreflop) AND (ncallbets <= 1)] ? HINT_There_Are_No_True_Raisers :
// Big blind = 0
BigBlindRaising ? 0 :
// Small blind = 1
SmallBlindRaising ? 1 :
// Normal players:
// Button = 2, CutOff = 3, ...
(nplayersdealt - DealPositionLastRaiser + 2)

##First##
0

##Middle##
1

##Last##
2

##Position##
(betposition == 1) ? First :
(betposition == nplayersplaying) ? Last :
Middle

//*****************************************************************************
//
// OpenPPL - Poker Tracker Symbols
//
// Please note: The OpenPPL-library does no longer provide 
// any PokerTracker-symbols, because similar symbols
// are now provided directly by OpenHoldem.
// Please see symbols_pokertracker.pdf for details.
//
//*****************************************************************************

//*****************************************************************************
//
// OpenPPL - Poker Tracker Symbols
//
// Sanity-checks for correct usage of symbols like Raises, Calls, etc.
// These symbols
//   * need game history
//   * need to be updated exactly once per orbit,
//     when it is our turn and we have isfinalanswer = true
//   * become stale immediately thereafter
//   * therefore are well-defined only at our turn,
//     and even then only in the main OPPL-functions    
//   * get misused a lot
//
// Therefore we keep a heartbeat-ID that updates together with these symbols
// and then we call VerifyHeartbeatID for each critical symbol
// and throw an error-message in case it gets used at inappropriate times.
//
//*****************************************************************************

##VerifyHeartbeatIDForBetsCallsChecksRaises##
(me_re_heartbeatID != randomheartbeat) ? ErrorCriticalSymbolsUsedAtWrongTime : 0

##ErrorCriticalSymbolsUsedAtWrongTime##
msgbox$ERROR_N_NHistory_Bsymbols_Blike_BBets_C_BCalls_C_BChecks_C_BRaises_NBotsLastPreflopAction_C_BRaisesBeforeFlop_D_D_D_Nare_Bnot_Byet_Binitialized_Bat_Bthis_Bpoint_Bof_Btime_D_NThey_Bare_Bwelldefined_Bonly_Bin_Bthe_Bmain_Bautoplayer_Blogic_Nat_Byour_Bturn_D_N_NUse_Bthem_Bonly_Bin_N_B_B_B_B_Bf$alli_D_D_Df$fold_N_B_B_B_B_Bf$preflop_D_D_Df$river_N

##RememberHeartbeatID##
me_st_heartbeatID_randomheartbeat

//*****************************************************************************
//
// OpenPPL - Initialization of memory symbols
//
// For history symbols and other information,
// that can't be retrieved from OH-symbols
// and from the current gamestate only.
//
//*****************************************************************************

##TimeToInitMemorySymbols##
// Some advanced symbols depend on memory symbols.
// They are designed to update once per orbit on our turn.
// However: depending on user-settings OpenHoldem might evaluate
// the necessary function even when it is not our turn.
// And incorrect delay-settings might also lead to multiple actions
// on identical frames (OH acts faster as casino/bring can update)
// So we check for isfinalanswer and a changed gamestate.
[isfinalanswer AND GameStateChanged]

##GameStateChanged##
// Change in dealerchair => new hand
   (dealerchair != me_re_MemOldGameStateDealerChair)
// Change in currentbet => we did act 
// and the autoplayer executed successfully   
OR (currentbet  != me_re_MemOldGameStateCurrentBet)
// Change in potsize: somebody else behind us acted, 
// so we checked or folded successfully
OR (pot			    != me_re_MemOldGameStatePotSize)
// Change in betround, if everybody checked 
// and potsize is the same
OR (betround    != me_re_MemOldGameStateBetround)

##RememberCurrentGameState##
// We can't use AND and OR here because of short circuiting.
// We must use an operator that evaluates both sites.
// The final result is meaningless.
    me_st_MemOldGameStateDealerChair_dealerchair
XOR me_st_MemOldGameStateCurrentBet_currentbet
XOR me_st_MemOldGameStatePotSize_pot
XOR me_st_MemOldGameStateBetround_betround

##InitMemorySymbols##
// In rare cases (or at OH-replay) it might happen,
// that autoplayer-actions don't have any effects.
// In this case we must not update the symbols again (increase counters, ...).
// However we have to update the heartbeat-ID to indicate
// that history symbols have been properly initialized.+
// http://www.maxinmontreal.com/forums/viewtopic.php?f=110&t=19407
WHEN NOT GameStateChanged RETURN RememberHeartbeatID FORCE	
// Memory symbols for game history have to be updated exactly once per turn
WHEN NOT TimeToInitMemorySymbols RETURN HINT_Nothing_To_Do_But_All_OK FORCE
// We can't use AND and OR here because of short circuiting.
// We must use an operator that evaluates both sites.
// The final result is meaningless.
//
// The heartbeat-ID has to be remembered first,
// because it is used to check if some history-symbols (Raises, Calls)
// are used correctly, at well-defined times only.
// And InitRaises, etc. will use them very soon -- and correctly.
WHEN Others RETURN (RememberHeartbeatID 
  XOR InitMissingSmallBlind 
  XOR InitBets
  XOR InitChecks
  XOR InitCalls
  XOR InitRaises
  XOR InitBotsLastPreflopAction
  XOR InitRaisesBeforeFlop
  XOR InitRaisesOnFlop
  XOR InitRaisesOnTurn
  XOR InitMaxOpponentStackSize
  XOR InitMinOpponentStackSize
  XOR InitStartingStackSize
  XOR InitStartingChips
  XOR RememberCurrentGameState)
FORCE

//*****************************************************************************
//
// OpenPPL - Various functions of minor importance or to do
//
//*****************************************************************************

##HaveBackdoorStraightDraw##
	(-1 + msgbox$HaveBackdoorstraightDraw_Bnot_Byet_Bimplemented_D_NYour_Bhelp_Bis_Brequired_D)
AND NOT HaveStraight 